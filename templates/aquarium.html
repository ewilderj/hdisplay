<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Aquarium</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: linear-gradient(to bottom, #001f3f 0%, #0074D9 100%);
    }

    #aquarium {
      width: 100vw;
      height: 100vh;
      display: block;
      background: transparent;
    }
  </style>
</head>
<body>
  <canvas id="aquarium"></canvas>
  <script>
    // Feeding event with food flakes
    let feedingActive = false;
    let feedingTimer = 0;
    let foodFlakes = [];
    const FLAKE_COUNT = 8;
    const FEED_SEP_RADIUS = 28;
    const FEED_SEP_RADIUS2 = FEED_SEP_RADIUS * FEED_SEP_RADIUS;
    const FEED_PERIOD_MS = 30000; // desired cadence (feed+gap total)
    const FEED_ACTIVE_MS = 8000;  // how long fish actively feed
    const FEED_JITTER_MS = 1500;  // small randomness to avoid lockstep
    let feedTimeoutId = null;

    function scheduleNextFeed(delayMs) {
      try { if (feedTimeoutId) clearTimeout(feedTimeoutId); } catch {}
      const jitter = Math.random() * FEED_JITTER_MS;
      feedTimeoutId = setTimeout(() => {
        if (!feedingActive) triggerFeeding();
      }, Math.max(0, delayMs) + jitter);
    }

    function triggerFeeding() {
      feedingActive = true;
      feedingTimer = Date.now();
      // Drop food flakes at random x near top (slower fall)
      foodFlakes = Array.from({ length: FLAKE_COUNT }, () => ({
        x: randomBetween(canvas.width * 0.2, canvas.width * 0.8),
        y: randomBetween(10, 40),
        vy: randomBetween(0.25, 0.5), // slower descent
        drift: randomBetween(-0.2, 0.2),
        alpha: 1,
        size: randomBetween(7, 13),
        color: randomBetween(0, 1) > 0.5 ? '#ffe066' : '#ffb347',
        active: true,
        // Z-axis for flakes
        z: randomBetween(0.2, 0.9),
        vz: randomBetween(-0.0006, 0.0006),
      }));
      for (let f of fish) f.feeding = true;
      // End feeding after active window, then schedule next feed after gap
      setTimeout(() => {
        feedingActive = false;
        for (let f of fish) f.feeding = false;
        // Do not clear flakes; let them settle and fade naturally
        const gap = Math.max(0, FEED_PERIOD_MS - FEED_ACTIVE_MS);
        scheduleNextFeed(gap);
      }, FEED_ACTIVE_MS);
    }

    // Kick off first feed with a small initial delay
    scheduleNextFeed(randomBetween(3000, 6000));

    function updateFish(f, idx) {
      // Phase 2 LOD: stagger fish updates across frames for performance
      if (fishUpdateStride > 1 && (idx % fishUpdateStride) !== (frameTick % fishUpdateStride)) {
        return;
      }
      // Feeding event: move toward nearest food flake if active
      if (f.feeding && feedingActive && foodFlakes.length > 0) {
        // Find nearest active flake in 3D
        let minDist2 = 1e12, target = null;
        const kz = depthDistancePx();
        for (const flake of foodFlakes) {
          if (!flake.active) continue;
          const dx = flake.x - f.x;
          const dy = flake.y - f.y;
          const dz = (flake.z ?? 0.5) - (f.z ?? 0.5);
          const d2 = dx*dx + dy*dy + (kz*dz) * (kz*dz);
          if (d2 < minDist2) {
            minDist2 = d2;
            target = flake;
          }
        }
        if (target) {
          const eatRadius = Math.max(6, (target.size || 8) * 0.6);
          const dx = target.x - f.x;
          const dy = target.y - f.y;
          const kz = depthDistancePx();
          const dz = (target.z ?? 0.5) - (f.z ?? 0.5);
          const d3 = Math.sqrt(dx*dx + dy*dy + (kz*dz)*(kz*dz));
          if (d3 <= eatRadius) {
            // Eat the flake
            target.active = false;
            // damp any residual approach velocity so fish settle smoothly
            f.feedVx = (f.feedVx || 0) * 0.2;
            f.feedVy = (f.feedVy || 0) * 0.2;
          } else {
            // Swim toward the flake with a tiny wobble so fish don't stack
            const t = Date.now() / 500 + f.phase;
            const ox = Math.cos(t) * 4;
            const oy = Math.sin(t) * 3;
            const tx = (target.x + ox) - f.x;
            const ty = (target.y + oy) - f.y;
            // Compute desired incremental move (kept similar to previous behavior)
            const desiredFx = tx * 0.03;
            const desiredFy = ty * 0.03;
            // Smooth the approach by maintaining a small approach velocity (prevents teleport/jump)
            f.feedVx = (f.feedVx || 0) + (desiredFx - (f.feedVx || 0)) * 0.18;
            f.feedVy = (f.feedVy || 0) + (desiredFy - (f.feedVy || 0)) * 0.18;
            // Apply the smoothed approach velocity to position
            f.x += f.feedVx;
            f.y += f.feedVy;
            // Adjust z toward target flake
            if (typeof target.z === 'number') {
              f.z += (target.z - (f.z ?? 0.5)) * 0.03;
            }
            // Face the flake while feeding
            if (Math.abs(tx) > 0.5) f.dir = tx > 0 ? 1 : -1;
            // Gentle separation from nearby feeding fish (jostling)
            let sx = 0, sy = 0;
            for (let j = 0; j < fish.length; ++j) {
              if (j === idx) continue;
              const nb = fish[j];
              if (!(nb.feeding && feedingActive)) continue;
              const dx2 = f.x - nb.x;
              const dy2 = f.y - nb.y;
              const d2 = dx2*dx2 + dy2*dy2;
              if (d2 > 1 && d2 < FEED_SEP_RADIUS2) {
                const d = Math.sqrt(d2);
                const repel = (FEED_SEP_RADIUS - d) / FEED_SEP_RADIUS;
                sx += (dx2 / d) * repel;
                sy += (dy2 / d) * repel;
              }
            }
            // Apply separation softly and add a touch of jitter
            f.x += sx * 1.0 + (Math.random() - 0.5) * 0.25;
            f.y += sy * 1.0 + (Math.random() - 0.5) * 0.2;
          }
        }
      } else {
        // when not feeding, gently decay any residual feed velocity to zero
        f.feedVx = (f.feedVx || 0) * 0.92;
        f.feedVy = (f.feedVy || 0) * 0.92;
        // Sine-wave vertical movement
        f.y += Math.sin(Date.now() / 600 + f.phase) * 0.3 * f.dir;
        f.x += Math.abs(f.vx) * f.dir;
        // Light z wander
        f.z = clamp((f.z ?? 0.5) + Math.sin(Date.now() / 3000 + (f.zPhase || 0)) * 0.002, 0, 1);
        // Simple flocking for midwater fish (zone 1)
        if (f.zone === 1) {
          let cx = 0, cy = 0, count = 0;
          // Phase 2: add lightweight separation to avoid overlap
          let sepX = 0, sepY = 0;
          const SEP_R2 = 40 * 40;
          for (let j = 0; j < fish.length; ++j) {
            if (j !== idx && fish[j].zone === 1) {
              const dx = fish[j].x - f.x;
              const dy = fish[j].y - f.y;
              const manhattan = Math.abs(dx) + Math.abs(dy);
              if (manhattan < 120) {
                cx += fish[j].x;
                cy += fish[j].y;
                count++;
              }
              const d2 = dx*dx + dy*dy;
              if (d2 > 1 && d2 < SEP_R2) {
                const d = Math.sqrt(d2);
                const repel = (40 - d) / 40; // stronger when closer
                sepX -= (dx / d) * repel;
                sepY -= (dy / d) * repel;
              }
            }
          }
          if (count > 0) {
            cx /= count; cy /= count;
            f.x += (cx - f.x) * 0.002;
            f.y += (cy - f.y) * 0.002;
          }
          // Apply separation softly
          f.x += sepX * 0.6;
          f.y += sepY * 0.6;
        }
      }
      // Bounce off edges and update direction to match travel
      if (f.x < 0) {
        f.dir = 1;
        f.x = 0;
        f.vx = Math.abs(f.vx);
      }
      if (f.x > canvas.width) {
        f.dir = -1;
        f.x = canvas.width;
        f.vx = -Math.abs(f.vx);
      }
      // Always face direction of travel (except while feeding)
      if (!(f.feeding && feedingActive)) {
        if (f.vx > 0) f.dir = 1;
        else if (f.vx < 0) f.dir = -1;
      }
      // Smoothly turn toward desired direction for rendering
      if (typeof f.face !== 'number') f.face = f.dir;
      f.face += (f.dir - f.face) * 0.15; // turn rate
      // Clamp to depth zone (y)
      if (f.zone === 0 && f.y < canvas.height * 0.12) f.y = canvas.height * 0.12;
      if (f.zone === 0 && f.y > canvas.height * 0.25) f.y = canvas.height * 0.25;
      if (f.zone === 1 && f.y < canvas.height * 0.35) f.y = canvas.height * 0.35;
      if (f.zone === 1 && f.y > canvas.height * 0.65) f.y = canvas.height * 0.65;
      if (f.zone === 2 && f.y < canvas.height * 0.7) f.y = canvas.height * 0.7;
      if (f.zone === 2 && f.y > canvas.height * 0.88) f.y = canvas.height * 0.88;
      // Clamp z range
      f.z = clamp(f.z ?? 0.5, 0, 1);
    }

    function drawFoodFlakes() {
      for (const flake of foodFlakes) {
        if (!flake.active) continue;
        ctx.save();
        ctx.globalAlpha = flake.alpha;
        const s = depthScale(flake.z ?? 0.5);
        ctx.beginPath();
        ctx.ellipse(flake.x, flake.y, flake.size * s, flake.size*0.5 * s, Math.sin(flake.x)*0.5, 0, Math.PI*2);
        ctx.fillStyle = flake.color;
        ctx.shadowColor = '#fff6';
        ctx.shadowBlur = 6;
        ctx.fill();
        ctx.restore();
      }
    }

    function updateFoodFlakes() {
      for (const flake of foodFlakes) {
        if (!flake.active) continue;
        flake.y += flake.vy;
        flake.x += flake.drift;
        // Z drift and clamp
        if (typeof flake.z === 'number') {
          flake.z += flake.vz || 0;
          if (flake.z < 0) { flake.z = 0; flake.vz = Math.abs(flake.vz || 0); }
          if (flake.z > 1) { flake.z = 1; flake.vz = -Math.abs(flake.vz || 0); }
        }
        // Fade out and deactivate if on sand
        if (flake.y > sandSurfaceY(flake.x) - 6) {
          flake.alpha -= 0.04;
          if (flake.alpha <= 0) flake.active = false;
        }
      }
      // Periodic cleanup to prevent buildup
      if (foodFlakes.length > 0 && Math.random() < 0.1) {
        foodFlakes = foodFlakes.filter(f => f.active);
      }
    }

    // Phase 1: Pi-optimized MVP
    const canvas = document.getElementById('aquarium');
    const ctx = canvas.getContext('2d');

    // Define sandSurfaceY early to avoid any temporal binding issues
    function sandSurfaceY(x) {
      // Sand is a slightly wavy line
      const base = canvas.height - sandHeight + Math.sin(x/90) * 4;
      // Add rock bumps
      for (const r of rocks) {
        const rx = canvas.width * r.x;
        const rw = canvas.width * r.w;
        if (x > rx - rw/2 && x < rx + rw/2) {
          const rel = (x - rx) / (rw/2);
          return base - Math.sqrt(1 - rel*rel) * r.h * canvas.height * 0.7;
        }
      }
      return base;
    }

    // Phase 2: adaptive quality and staggered updates for fish (LOD)
    let lastFrameTime = (typeof performance !== 'undefined' ? performance.now() : Date.now());
    let frameTimeAvg = 16; // ms
    let fishUpdateStride = 1; // 1=all fish, 2=half per frame, 3=third per frame
    let frameTick = 0;
    function adaptQuality() {
      if (frameTimeAvg > 50) {
        fishUpdateStride = 3;
      } else if (frameTimeAvg > 40) {
        fishUpdateStride = 2;
      } else {
        fishUpdateStride = 1;
      }
    }

  // Day/night filter removed

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Fish species/colors
    const FISH_COLORS = ['#FFDC00', '#7FDBFF', '#FF4136'];
    const FISH_COUNT = 14; // Phase 2: slightly larger population (15-20 total with other creatures)
    const FISH_SHAPES = [
      // [bodyLength, bodyHeight, tailLength, tailHeight]
      [60, 24, 18, 16],
      [48, 18, 14, 12],
      [54, 20, 16, 14]
    ];

    // Phase 2: Add jellyfish, turtle, crab, feeding event, improved flocking, depth-based behaviors
    const JELLYFISH_COUNT = 2;
    const TURTLE_COUNT = 1;
    const CRAB_COUNT = 2; // Phase 2: 1-2 crabs

    function randomBetween(a, b) {
      return a + Math.random() * (b - a);
    }
    // Z-axis helpers
    const DEPTH_MIN_SCALE = 0.75;
    const DEPTH_MAX_SCALE = 1.25;
    function depthDistancePx() { return Math.min(canvas.width, canvas.height) * 0.6; }
    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
    function depthScale(z) {
      const zz = clamp((z ?? 0.5), 0, 1);
      return DEPTH_MIN_SCALE + (DEPTH_MAX_SCALE - DEPTH_MIN_SCALE) * (1 - zz);
    }

    function makeFish(i) {
      const species = i % FISH_SHAPES.length;
      const vx = randomBetween(0.7, 1.2) * (Math.random() < 0.5 ? 1 : -1);
      // Assign depth zone: 0=surface, 1=mid, 2=bottom
      const zone = i < 4 ? 0 : (i < 7 ? 1 : 2);
      let y;
      if (zone === 0) y = randomBetween(canvas.height * 0.12, canvas.height * 0.25);
      else if (zone === 1) y = randomBetween(canvas.height * 0.35, canvas.height * 0.65);
      else y = randomBetween(canvas.height * 0.7, canvas.height * 0.88);

      // Species kind selection (weighted): standard > puffer/angel/striped
      const r = Math.random();
      const kind = r < 0.55 ? 'standard' : r < 0.7 ? 'puffer' : r < 0.85 ? 'angelfish' : 'striped';
      const PALETTES = {
        standard: FISH_COLORS,
        puffer: ['#F5C542', '#E67E22', '#2ECC71', '#E74C3C'],
        angelfish: ['#F1C40F', '#ECF0F1', '#2C3E50', '#34495E'],
        striped: ['#00D1FF', '#00FFA3', '#00B7FF', '#92FE9D'],
      };
      const palette = PALETTES[kind] || FISH_COLORS;
      const color = palette[(Math.random() * palette.length) | 0];

      return {
        x: randomBetween(0, canvas.width),
        y,
        vx,
        vy: randomBetween(-0.2, 0.2),
        color,
        shape: FISH_SHAPES[species],
        dir: vx >= 0 ? 1 : -1,
        face: vx >= 0 ? 1 : -1, // smooth facing for turn animation
        phase: Math.random() * Math.PI * 2,
        zone,
        feeding: false,
        kind,
        // Z-axis
        z: randomBetween(0.15, 0.95),
        zPhase: Math.random() * Math.PI * 2,
        // approach velocity used only during feeding to smooth motion
        feedVx: 0,
        feedVy: 0,
      };
    }

    let fish = Array.from({length: FISH_COUNT}, (_, i) => makeFish(i));

    // Jellyfish
    function makeJelly(i) {
      const pinks = [
        'rgba(255, 105, 180, 0.28)', // hot pink
        'rgba(255, 140, 180, 0.25)', // softer pink
        'rgba(255, 182, 193, 0.25)'  // light pink
      ];
      return {
        x: randomBetween(canvas.width * 0.1, canvas.width * 0.9),
        y: randomBetween(canvas.height * 0.15, canvas.height * 0.5),
        phase: Math.random() * Math.PI * 2,
        speed: randomBetween(0.1, 0.2),
        size: randomBetween(28, 38),
        color: pinks[(Math.random() * pinks.length) | 0]
      };
    }
    let jellyfish = Array.from({length: JELLYFISH_COUNT}, (_, i) => makeJelly(i));

    // Turtle
    function makeTurtle() {
      return {
        x: randomBetween(-100, canvas.width * 0.2),
        y: randomBetween(canvas.height * 0.3, canvas.height * 0.7),
        vx: randomBetween(0.3, 0.5),
        dir: 1,
        size: 44,
        phase: Math.random() * Math.PI * 2, // per-turtle swim phase
        flapMs: randomBetween(900, 1300) // flipper cycle duration (ms)
      };
    }
    let turtles = Array.from({length: TURTLE_COUNT}, makeTurtle);

    // Crab
    function makeCrab() {
      return {
        x: randomBetween(0, canvas.width * 0.8),
        y: canvas.height * 0.93,
        vx: randomBetween(0.2, 0.4),
        dir: Math.random() < 0.5 ? 1 : -1,
        size: 33 // 50% larger
      };
    }
    let crabs = Array.from({length: CRAB_COUNT}, makeCrab);

    // Shared transform for fish rendering (scale/rotation based on facing and zone + depth)
    function renderFishTransformed(f, drawBody) {
      ctx.save();
      ctx.translate(f.x, f.y);
      const sizeScale = f.zone === 0 ? 0.95 : (f.zone === 1 ? 1.0 : 1.08);
      const zScale = depthScale(f.z);
      const sx = Math.sign(f.face || f.dir) * Math.max(0.35, Math.abs(f.face || f.dir));
      ctx.scale(sx * sizeScale * zScale, sizeScale * zScale);
      ctx.rotate(Math.sin(Date.now() / 800 + f.phase) * 0.08 * Math.sign(sx));
      drawBody();
      ctx.restore();
    }

    function drawBodyStandard(f) {
      // Body
      const grad = ctx.createLinearGradient(-f.shape[0]/2, 0, f.shape[0]/2, 0);
      grad.addColorStop(0, '#fff8');
      grad.addColorStop(0.2, f.color);
      grad.addColorStop(1, '#2228');
      ctx.beginPath();
      ctx.ellipse(0, 0, f.shape[0]/2, f.shape[1]/2, 0, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.globalAlpha = 0.92;
      ctx.fill();
      // Top fin
      ctx.beginPath();
      ctx.moveTo(-f.shape[0]*0.1, -f.shape[1]/2);
      ctx.lineTo(0, -f.shape[1]*0.9);
      ctx.lineTo(f.shape[0]*0.1, -f.shape[1]/2);
      ctx.closePath();
      ctx.fillStyle = '#fff5';
      ctx.globalAlpha = 0.7;
      ctx.fill();
      // Tail
      ctx.beginPath();
      ctx.moveTo(-f.shape[0]/2, 0);
      ctx.lineTo(-f.shape[0]/2 - f.shape[2], -f.shape[3]/2);
      ctx.lineTo(-f.shape[0]/2 - f.shape[2], f.shape[3]/2);
      ctx.closePath();
      const tailGrad = ctx.createLinearGradient(-f.shape[0]/2 - f.shape[2], 0, -f.shape[0]/2, 0);
      tailGrad.addColorStop(0, '#fff7');
      tailGrad.addColorStop(1, '#333b');
      ctx.fillStyle = tailGrad;
      ctx.globalAlpha = 0.8;
      ctx.fill();
      // Side fin
      ctx.beginPath();
      ctx.ellipse(-f.shape[0]*0.1, f.shape[1]*0.25, f.shape[0]*0.13, f.shape[1]*0.18, Math.PI/6, 0, Math.PI*2);
      ctx.fillStyle = '#fff6';
      ctx.globalAlpha = 0.5;
      ctx.fill();
      // Mouth
      ctx.beginPath();
      ctx.arc(f.shape[0]/3, f.shape[1]*0.13, 4, Math.PI*0.15, Math.PI*0.85, false);
      ctx.lineWidth = 1.2;
      ctx.strokeStyle = '#222a';
      ctx.globalAlpha = 0.8;
      ctx.stroke();
      // Eye
      ctx.beginPath();
      ctx.arc(f.shape[0]/4, -f.shape[1]/6, 3, 0, Math.PI * 2);
      ctx.fillStyle = '#222';
      ctx.globalAlpha = 1;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(f.shape[0]/4 + 1, -f.shape[1]/6 - 1, 1, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.7;
      ctx.fill();
    }

    function drawBodyPuffer(f) {
      const base = 18;
      const pulse = 1 + 0.05 * Math.sin(Date.now() / 600 + f.phase);
      const R = base * pulse;
      // Spikes
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = '#c03a2b88';
      ctx.lineWidth = 2;
      for (let a = 0; a < Math.PI * 2; a += Math.PI / 6) {
        const x1 = Math.cos(a) * (R + 0);
        const y1 = Math.sin(a) * (R + 0);
        const x2 = Math.cos(a) * (R + 6);
        const y2 = Math.sin(a) * (R + 6);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      ctx.restore();
      // Body
      const g = ctx.createRadialGradient(-R*0.2, -R*0.2, R*0.2, 0, 0, R);
      g.addColorStop(0, '#fff8');
      g.addColorStop(0.4, f.color);
      g.addColorStop(1, '#3338');
      ctx.beginPath();
      ctx.ellipse(0, 0, R * 1.05, R, 0, 0, Math.PI * 2);
      ctx.fillStyle = g;
      ctx.globalAlpha = 0.95;
      ctx.fill();
      // Fins
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.ellipse(-R * 0.4, R * 0.2, R * 0.35, R * 0.18, Math.PI / 6, 0, Math.PI * 2);
      ctx.fillStyle = '#fff6';
      ctx.fill();
      // Mouth (small circle)
      ctx.beginPath();
      ctx.arc(R * 0.7, 0, 2.2, 0, Math.PI * 2);
      ctx.fillStyle = '#222a';
      ctx.globalAlpha = 0.8;
      ctx.fill();
      // Eye
      ctx.globalAlpha = 1;
      ctx.beginPath();
      ctx.arc(R * 0.45, -R * 0.25, 3, 0, Math.PI * 2);
      ctx.fillStyle = '#222';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(R * 0.45 + 1, -R * 0.25 - 1, 1, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.7;
      ctx.fill();
    }

    function drawBodyAngelfish(f) {
      const L = 52; // length
      const H = 34; // height
      // Body (diamond)
      const g = ctx.createLinearGradient(-L*0.5, 0, L*0.5, 0);
      g.addColorStop(0, '#fff7');
      g.addColorStop(0.25, f.color);
      g.addColorStop(1, '#2228');
      ctx.beginPath();
      ctx.moveTo(-L * 0.35, 0);
      ctx.lineTo(0, -H * 0.65);
      ctx.lineTo(L * 0.5, 0);
      ctx.lineTo(0, H * 0.65);
      ctx.closePath();
      ctx.fillStyle = g;
      ctx.globalAlpha = 0.92;
      ctx.fill();
      // Tall dorsal fin
      ctx.beginPath();
      ctx.moveTo(-L * 0.1, -H * 0.65);
      ctx.lineTo(L * 0.2, -H * 1.3);
      ctx.lineTo(L * 0.35, -H * 0.35);
      ctx.closePath();
      ctx.fillStyle = '#fff5';
      ctx.globalAlpha = 0.6;
      ctx.fill();
      // Ventral fin
      ctx.beginPath();
      ctx.moveTo(-L * 0.05, H * 0.65);
      ctx.lineTo(L * 0.22, H * 1.2);
      ctx.lineTo(L * 0.34, H * 0.35);
      ctx.closePath();
      ctx.fillStyle = '#fff5';
      ctx.globalAlpha = 0.6;
      ctx.fill();
      // Tail
      ctx.beginPath();
      ctx.moveTo(-L * 0.5, 0);
      ctx.lineTo(-L * 0.78, -H * 0.28);
      ctx.lineTo(-L * 0.78, H * 0.28);
      ctx.closePath();
      ctx.fillStyle = '#3338';
      ctx.globalAlpha = 0.8;
      ctx.fill();
      // Eye & mouth
      ctx.globalAlpha = 1;
      ctx.beginPath();
      ctx.arc(L * 0.28, -H * 0.18, 3, 0, Math.PI * 2);
      ctx.fillStyle = '#222';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(L * 0.35, H * 0.1, 3, Math.PI * 0.2, Math.PI * 0.8);
      ctx.strokeStyle = '#222a';
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }

    function drawBodyStriped(f) {
      const L = 56;
      const H = 18;
      // Body
      const g = ctx.createLinearGradient(-L/2, 0, L/2, 0);
      g.addColorStop(0, '#fff8');
      g.addColorStop(0.2, f.color);
      g.addColorStop(1, '#2228');
      ctx.beginPath();
      ctx.ellipse(0, 0, L/2, H/2, 0, 0, Math.PI * 2);
      ctx.fillStyle = g;
      ctx.globalAlpha = 0.94;
      ctx.fill();
      // Vertical stripes (3 light bands)
      ctx.globalAlpha = 0.28;
      ctx.fillStyle = '#ffffff';
      for (let i = -1; i <= 1; i++) {
        ctx.beginPath();
        const x = (i * L) / 6;
        ctx.ellipse(x, 0, L * 0.06, H * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      // Tail
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(-L/2, 0);
      ctx.lineTo(-L/2 - 14, -H/2);
      ctx.lineTo(-L/2 - 14, H/2);
      ctx.closePath();
      ctx.fillStyle = '#3339';
      ctx.fill();
      // Fin
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.ellipse(-L * 0.1, H * 0.5, L * 0.12, H * 0.5, Math.PI / 6, 0, Math.PI * 2);
      ctx.fillStyle = '#fff6';
      ctx.fill();
      // Eye
      ctx.globalAlpha = 1;
      ctx.beginPath();
      ctx.arc(L * 0.25, -H * 0.35, 3, 0, Math.PI * 2);
      ctx.fillStyle = '#222';
      ctx.fill();
    }

    function drawFish(f) {
      if (f.kind === 'puffer') {
        renderFishTransformed(f, () => drawBodyPuffer(f));
      } else if (f.kind === 'angelfish') {
        renderFishTransformed(f, () => drawBodyAngelfish(f));
      } else if (f.kind === 'striped') {
        renderFishTransformed(f, () => drawBodyStriped(f));
      } else {
        renderFishTransformed(f, () => drawBodyStandard(f));
      }
    }

    // Sand and rocks at the bottom
    const sandHeight = 38;
    const rocks = [
      { x: 0.18, w: 0.09, h: 0.04, color: '#888' },
      { x: 0.32, w: 0.07, h: 0.03, color: '#aaa' },
      { x: 0.5, w: 0.13, h: 0.06, color: '#666' },
      { x: 0.7, w: 0.08, h: 0.04, color: '#bbb' },
      { x: 0.82, w: 0.06, h: 0.03, color: '#999' }
    ];

    // Seaweed clusters along the sand
    const seaweedClusters = [
      { x: 0.08, h: 0.22, blades: 7, swayMs: 2400 },
      { x: 0.16, h: 0.2, blades: 6, swayMs: 2200 },
      { x: 0.24, h: 0.24, blades: 8, swayMs: 2600 },
      { x: 0.34, h: 0.18, blades: 6, swayMs: 2100 },
      { x: 0.48, h: 0.21, blades: 7, swayMs: 2300 },
      { x: 0.62, h: 0.19, blades: 6, swayMs: 2250 },
      { x: 0.72, h: 0.23, blades: 8, swayMs: 2550 },
      { x: 0.84, h: 0.2, blades: 6, swayMs: 2150 },
      { x: 0.92, h: 0.17, blades: 5, swayMs: 2050 },
    ];

    function drawSeaweed() {
      const t = Date.now();
      ctx.save();
      ctx.lineCap = 'round';
      for (const c of seaweedClusters) {
        const baseX = canvas.width * c.x;
        const baseY = sandSurfaceY(baseX) - 2;
        for (let i = 0; i < c.blades; i++) {
          const k = (i - (c.blades - 1) / 2) / ((c.blades - 1) / 2 || 1);
          const x = baseX + k * 10;
          const h = canvas.height * c.h * (0.8 + 0.3 * (1 - Math.abs(k)));
          const sway = Math.sin((t + i * 300) / (c.swayMs || 2400)) * (8 + 6 * (1 - Math.abs(k)));
          ctx.beginPath();
          ctx.moveTo(x, baseY);
          ctx.bezierCurveTo(
            x - 6, baseY - h * 0.35,
            x + sway, baseY - h * 0.7,
            x + sway * 0.6, baseY - h
          );
          ctx.strokeStyle = 'rgba(34, 139, 34, 0.7)'; // forest green
          ctx.lineWidth = 3 - Math.abs(k);
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    function drawSandAndRocks() {
      // Sand
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      for (let x = 0; x <= canvas.width; x += 8) {
        ctx.lineTo(x, sandSurfaceY(x));
      }
      ctx.lineTo(canvas.width, canvas.height);
      ctx.closePath();
      const sandGrad = ctx.createLinearGradient(0, canvas.height-sandHeight, 0, canvas.height);
      sandGrad.addColorStop(0, '#ffeabf');
      sandGrad.addColorStop(1, '#e2c48d');
      ctx.fillStyle = sandGrad;
      ctx.globalAlpha = 0.95;
      ctx.fill();
      // Rocks
      for (const r of rocks) {
        ctx.save();
        ctx.beginPath();
        ctx.ellipse(canvas.width*r.x, canvas.height-sandHeight*0.5, canvas.width*r.w/2, canvas.height*r.h/2, 0, 0, Math.PI*2);
        ctx.fillStyle = r.color;
        ctx.globalAlpha = 0.7;
        ctx.shadowColor = '#2226';
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.restore();
      }
      ctx.restore();
    }

    function drawCoral() {
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = '#FF851B';
      ctx.beginPath();
      ctx.moveTo(canvas.width * 0.1, canvas.height);
      ctx.bezierCurveTo(canvas.width * 0.12, canvas.height * 0.8, canvas.width * 0.15, canvas.height * 0.7, canvas.width * 0.13, canvas.height * 0.5);
      ctx.lineTo(canvas.width * 0.14, canvas.height);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(canvas.width * 0.2, canvas.height);
      ctx.bezierCurveTo(canvas.width * 0.22, canvas.height * 0.85, canvas.width * 0.25, canvas.height * 0.8, canvas.width * 0.23, canvas.height * 0.6);
      ctx.lineTo(canvas.width * 0.24, canvas.height);
      ctx.closePath();
      ctx.fill();
      // Extra coral for phase 2
      ctx.beginPath();
      ctx.moveTo(canvas.width * 0.85, canvas.height);
      ctx.bezierCurveTo(canvas.width * 0.87, canvas.height * 0.8, canvas.width * 0.9, canvas.height * 0.7, canvas.width * 0.88, canvas.height * 0.5);
      ctx.lineTo(canvas.width * 0.89, canvas.height);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
    // Draw jellyfish
    function drawJelly(j) {
      ctx.save();
      ctx.translate(j.x, j.y);
      const tNow = Date.now();
      // Bell with pink radial gradient
      const bellGrad = ctx.createRadialGradient(0, 0, j.size*0.12, 0, 0, j.size*0.65);
      bellGrad.addColorStop(0, 'rgba(255,255,255,0.75)');
      bellGrad.addColorStop(0.5, j.color);
      bellGrad.addColorStop(1, 'rgba(255, 182, 193, 0.15)');
      ctx.beginPath();
      ctx.ellipse(0, 0, j.size * 0.62, j.size * (0.42 + Math.sin(tNow/700 + j.phase)*0.06), 0, Math.PI, 2*Math.PI);
      ctx.fillStyle = bellGrad;
      ctx.globalAlpha = 0.9;
      ctx.fill();
      // Bell highlight
      ctx.beginPath();
      ctx.ellipse(-j.size*0.15, -j.size*0.08, j.size*0.18, j.size*0.09, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.45)';
      ctx.globalAlpha = 1;
      ctx.fill();
      // Tentacles: longer, wavier pink streamers
      const N = 10;
      for (let i = 0; i < N; i++) {
        const k = (i - (N-1)/2) / ((N-1)/2);
        const x0 = k * j.size * 0.35;
        const len = j.size * (1.1 + 0.25 * (1 - Math.abs(k)));
        const w1 = Math.sin(tNow/480 + i + j.phase) * 10;
        const w2 = Math.cos(tNow/420 + i*1.3 + j.phase) * 12;
        ctx.beginPath();
        ctx.moveTo(x0, j.size*0.08);
        ctx.bezierCurveTo(
          x0 + w1, j.size*0.35,
          x0 + w2, len * 0.75,
          x0 + Math.sin(tNow/640 + i + j.phase)*6, len
        );
        ctx.strokeStyle = 'rgba(255, 105, 180, 0.6)';
        ctx.lineWidth = 1.4 - 0.08 * Math.abs(k) * 10;
        ctx.globalAlpha = 0.6;
        ctx.stroke();
      }
      ctx.restore();
    }

    // Draw turtle
    function drawTurtle(t) {
      ctx.save();
      ctx.translate(t.x, t.y);
      ctx.scale(t.dir, 1);
      const time = Date.now();
      const ms = t.flapMs || 1100;
      const swim = Math.sin(time / ms + t.phase);
      const swimBack = Math.sin(time / ms + t.phase + Math.PI);
      const bob = Math.sin(time / (ms * 1.8) + t.phase) * t.size * 0.06;
      ctx.translate(0, bob);

      // Shell with pattern
      const shellGrad = ctx.createRadialGradient(0, 0, t.size*0.2, 0, 0, t.size);
      shellGrad.addColorStop(0, '#fff8');
      shellGrad.addColorStop(0.5, '#3D9970');
      shellGrad.addColorStop(1, '#155a3a');
      ctx.beginPath();
      ctx.ellipse(0, 0, t.size, t.size*0.6, 0, 0, Math.PI*2);
      ctx.fillStyle = shellGrad;
      ctx.globalAlpha = 0.9;
      ctx.fill();
      // Shell pattern spots
      ctx.globalAlpha = 0.3;
      for (let i = 0; i < 5; ++i) {
        ctx.beginPath();
        ctx.ellipse(Math.cos(i)*t.size*0.4, Math.sin(i)*t.size*0.2, t.size*0.18, t.size*0.09, 0, 0, Math.PI*2);
        ctx.fillStyle = '#2ECC40';
        ctx.fill();
      }
      // Head (slight nod)
      ctx.save();
      ctx.translate(t.size*0.9, 0);
      ctx.rotate(0.08 * swim);
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.ellipse(0, 0, t.size*0.25, t.size*0.18, 0, 0, Math.PI*2);
      ctx.fillStyle = '#2ECC40';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(t.size*0.08, t.size*0.05, 5, Math.PI*0.15, Math.PI*0.85, false);
      ctx.lineWidth = 1.1;
      ctx.strokeStyle = '#155a3a';
      ctx.stroke();
      // Eye
      ctx.beginPath();
      ctx.arc(t.size*0.15, -t.size*0.05, 2.5, 0, Math.PI*2);
      ctx.fillStyle = '#222';
      ctx.globalAlpha = 1;
      ctx.fill();
      ctx.restore();

      // Animated flippers: front pair
      const finFill = '#2ECC40';
      const finAlpha = 0.55;
      for (const side of [-1, 1]) {
        // Front flipper
        ctx.save();
        ctx.translate(side * t.size * 0.55, t.size * 0.35);
        ctx.rotate(side * (0.25 + 0.25 * swim));
        ctx.globalAlpha = finAlpha;
        ctx.beginPath();
        ctx.ellipse(0, 0, t.size*0.22, t.size*0.10, 0, 0, Math.PI*2);
        ctx.fillStyle = finFill;
        ctx.fill();
        ctx.restore();

        // Rear flipper
        ctx.save();
        ctx.translate(side * -t.size * 0.4, t.size * 0.3);
        ctx.rotate(side * (-0.12 + 0.18 * swimBack));
        ctx.globalAlpha = finAlpha * 0.9;
        ctx.beginPath();
        ctx.ellipse(0, 0, t.size*0.18, t.size*0.085, 0, 0, Math.PI*2);
        ctx.fillStyle = finFill;
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    }

    // Draw crab (larger with more prominent claws; solid filled mouth)
    function drawCrab(c) {
      ctx.save();
      ctx.translate(c.x, c.y);
      ctx.scale(c.dir, 1);

      // Dimensions
      const bodyW = c.size * 0.9;
      const bodyH = c.size * 0.55;

      // Draw legs behind body
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#b92a22';
      ctx.lineWidth = 2.2;
      for (const side of [-1, 1]) {
        for (let i = 0; i < 3; i++) {
          const y = -2 + i * 4;
          ctx.beginPath();
          ctx.moveTo(side * bodyW * 0.5, y);
          ctx.quadraticCurveTo(
            side * bodyW * (0.9 + 0.14 * i),
            y - 3,
            side * bodyW * (1.2 + 0.16 * i),
            y + 6
          );
          ctx.stroke();
        }
      }
      ctx.restore();

      // Arms + claws
      ctx.save();
      ctx.strokeStyle = '#a31b14';
      ctx.lineWidth = 3.2;
      for (const side of [-1, 1]) {
        const ax = side * bodyW * 0.6;
        const ay = -bodyH * 0.05;
        const hx = side * bodyW * 1.18;
        const hy = -bodyH * 0.22;
        // arm
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.quadraticCurveTo(side * bodyW * 0.9, ay - 6, hx, hy);
        ctx.stroke();
        // pincer (two filled lobes)
        ctx.save();
        ctx.translate(hx, hy);
        ctx.rotate(side * 0.12);
        ctx.fillStyle = '#e2463a';
        ctx.beginPath();
        ctx.ellipse(-side * 9, -3, 11, 7, 0.2, 0, Math.PI * 2);
        ctx.ellipse(-side * 3, 4, 9, 6, -0.2, 0, Math.PI * 2);
        ctx.fill();
        // outline to pop claws
        ctx.strokeStyle = '#7a0f0f';
        ctx.lineWidth = 1.3;
        ctx.stroke();
         ctx.restore();
      }
      ctx.restore();

      // Body (shell) with subtle radial gradient and outline
      const shellGrad = ctx.createRadialGradient(0, -bodyH * 0.2, bodyW * 0.1, 0, 0, bodyW);
      shellGrad.addColorStop(0, '#ff6b5a');
      shellGrad.addColorStop(0.5, '#ff3b2f');
      shellGrad.addColorStop(1, '#b0120d');
      ctx.fillStyle = shellGrad;
      ctx.beginPath();
      ctx.ellipse(0, 0, bodyW, bodyH, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#7a0f0f';
      ctx.lineWidth = 1.2;
      ctx.stroke();

      // Mouth: filled smile (not transparent)
      ctx.fillStyle = '#7a0f0f';
      const r = Math.max(5, c.size * 0.27 * 0.5);
      const my = bodyH * 0.15;
      ctx.beginPath();
      ctx.arc(0, my, r, Math.PI * 0.15, Math.PI * 0.85, false);
      // give thickness by offset curve
      const endX = r * Math.cos(Math.PI * 0.85);
      const startX = r * Math.cos(Math.PI * 0.15);
      ctx.lineTo(endX, my + 2);
      ctx.arc(0, my + 2, r - 1.5, Math.PI * 0.85, Math.PI * 0.15, true);
      ctx.lineTo(startX, my);
      ctx.closePath();
      ctx.fill();

      // Eye stalks and eyes
      for (const side of [-1, 1]) {
        const ex = side * bodyW * 0.25;
        const eyTop = -bodyH * 0.35;
        ctx.strokeStyle = '#7a0f0f';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(ex, -bodyH * 0.12);
        ctx.lineTo(ex, eyTop + 2);
        ctx.stroke();
        // eye
        ctx.beginPath();
        ctx.arc(ex, eyTop, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#111';
        ctx.fill();
        // highlight
        ctx.beginPath();
        ctx.arc(ex + 1, eyTop - 1, 1, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
      }

      ctx.restore();
    }

    function drawBubbles() {
      // Simple static bubbles for MVP
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#fff';
      for (let i = 0; i < 8; ++i) {
        ctx.beginPath();
        ctx.arc(canvas.width * 0.15 + Math.sin(Date.now()/1000 + i)*8, canvas.height * 0.7 - i*30 - (Date.now()/30)%canvas.height*0.01, 6-i*0.5, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    function updateJelly(j) {
      j.y += Math.sin(Date.now()/1200 + j.phase) * 0.15;
      j.x += Math.sin(Date.now()/1800 + j.phase) * 0.08;
      if (j.y < canvas.height * 0.1) j.y = canvas.height * 0.1;
      if (j.y > canvas.height * 0.7) j.y = canvas.height * 0.7;
    }

    function updateTurtle(t, idx) {
      if (idx % 5 !== (Math.floor(Date.now()/1000)%5)) return; // update every 5th frame
      t.x += t.vx * t.dir;
      if (t.x > canvas.width + 100) {
        t.x = -100;
        t.y = randomBetween(canvas.height * 0.3, canvas.height * 0.7);
      }
    }

    function updateCrab(c) {
      c.x += c.vx * c.dir;
      if (c.x < 0) { c.dir = 1; c.x = 0; }
      if (c.x > canvas.width - 20) { c.dir = -1; c.x = canvas.width - 20; }
      // Make crab crawl over sand/rocks
      const ySurf = sandSurfaceY(c.x);
      // Add a little bobble for legs
      c.y = ySurf - 2 + Math.sin(Date.now()/300 + c.x/40)*2;
    }

    // Minimal decorations hook (currently seaweed only)
    function drawDecorations() {
      drawSeaweed();
    }

    function loop() {
      const now = (typeof performance !== 'undefined' ? performance.now() : Date.now());
      const dt = now - lastFrameTime;
      lastFrameTime = now;
      frameTimeAvg = frameTimeAvg * 0.9 + dt * 0.1;
      adaptQuality();
      frameTick++;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawSandAndRocks();
      drawDecorations();
      drawCoral();
      drawBubbles();
      // Phase 2 creatures
      for (let i = 0; i < jellyfish.length; ++i) {
        updateJelly(jellyfish[i]);
        drawJelly(jellyfish[i]);
      }
      for (let i = 0; i < turtles.length; ++i) {
        updateTurtle(turtles[i], i);
        drawTurtle(turtles[i]);
      }
      for (let i = 0; i < crabs.length; ++i) {
        updateCrab(crabs[i]);
        drawCrab(crabs[i]);
      }
      // Fish update
      for (let i = 0; i < fish.length; ++i) {
        updateFish(fish[i], i);
      }
      // Build render queue for fish + flakes (sorted by depth)
      const renderables = [];
      for (let i = 0; i < fish.length; ++i) {
        const fi = fish[i];
        renderables.push({ z: fi.z ?? 0.5, y: fi.y, draw: () => drawFish(fi) });
      }
      if (feedingActive || foodFlakes.length > 0) {
        updateFoodFlakes();
        for (const flake of foodFlakes) {
          if (!flake.active) continue;
          const ff = flake;
          renderables.push({ z: ff.z ?? 0.5, y: ff.y, draw: () => {
            // draw single flake with depth scale
            ctx.save();
            ctx.globalAlpha = ff.alpha;
            const s = depthScale(ff.z ?? 0.5);
            ctx.beginPath();
            ctx.ellipse(ff.x, ff.y, ff.size * s, ff.size*0.5 * s, Math.sin(ff.x)*0.5, 0, Math.PI*2);
            ctx.fillStyle = ff.color;
            ctx.shadowColor = '#fff6';
            ctx.shadowBlur = 6;
            ctx.fill();
            ctx.restore();
          }});
        }
      }
      renderables.sort((a, b) => ((b.z - a.z) || ((a.y ?? 0) - (b.y ?? 0)))); // far first, stable by y
      for (const r of renderables) r.draw();

      requestAnimationFrame(loop);
    }
    loop();
    
    // Cleanup feeding timeout when page unloads or template changes
    window.addEventListener('beforeunload', () => {
      if (feedTimeoutId) clearTimeout(feedTimeoutId);
    });
    
    // Store cleanup globally
    if (window.hdisplay) {
      if (window.hdisplay.aquariumCleanup) {
        window.hdisplay.aquariumCleanup();
      }
      window.hdisplay.aquariumCleanup = () => {
        if (feedTimeoutId) clearTimeout(feedTimeoutId);
      };
    }
  </script>
</body>
</html>
